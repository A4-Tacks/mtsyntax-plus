use mtsyntax_plus::{build, parser, BuildContext, Error, OutputContext};
use std::{
    env::args,
    fs::File,
    io::{self, stdin, stdout, Read, Write},
    process::exit,
};

fn proc_it(mut io: impl Read) -> io::Result<()> {
    let mut input = String::new();
    io.read_to_string(&mut input)?;
    drop(io);

    let (begin, rules, end) = match parser::script(&input) {
        Ok(x) => x,
        Err(e) => {
            eprintln!("ParseError: at {}:{},",
                e.location.line,
                e.location.column,
            );
            eprintln!("expected {}", e.expected);
            exit(3)
        },
    };

    let mut out = stdout().lock();

    let indent = begin
        .rsplit_once(|ch| ! matches!(ch, ' ' | '\t'))
        .map_or("    ", |(_, ind)| ind);

    write!(&mut out, "{begin}// Generated by mtsyntax-plus begin\n{indent}")?;

    let mut ctx = BuildContext::default();
    let mut octx =
        OutputContext::new(|args| {
            write!(&mut out, "{args}")
        });

    if let Some(' ') | None = indent.chars().next() {
        octx.indent_level = indent.len() as u32 / 4;
        octx.indent_str = "    ";
    } else {
        octx.indent_str = "\t";
        octx.indent_level = indent.len() as u32;
    }

    if let Err(e) = build(rules, &mut octx, &mut ctx) {
        println!();
        match e {
            Error::UndefineRef(name) => {
                eprintln!("BuildError: undefine reference `{name}`");
            },
            Error::RepeatDefineName(name) => {
                eprintln!("BuildError: repeat define name `{name}`");
            },
            Error::RefNotARegexp(name) => {
                eprintln!("BuildError: reference `{name}` is not a regexp define");
            },
            Error::IOError(e) => Err(e)?,
        }
        exit(3)
    }

    write!(&mut out, "// Generated by mtsyntax-plus end\n{end}")?;

    Ok(())
}

fn main() {
    let options = getopts_macro::getopts_options! {
        -h  --help          "Show help message";
        -v  --version       "Show version";
        .parsing_style(getopts_macro::getopts::ParsingStyle::FloatingFrees)
    };
    let args = &mut args();
    let proc = args.next().unwrap();
    let matched = match options.parse(args) {
        Ok(matched) => matched,
        Err(e) => {
            eprintln!("{e}");
            exit(2)
        },
    };
    if matched.opt_present("help") {
        let biref = options.short_usage(&proc);
        let about = "将MT管理器语法进行强化, 使其正则定义可以携带颜色";
        let info = format!("{biref} [FILES..]\n{about}");
        let usage = options.usage(&info);
        println!("{usage}");
        println!("input from stdin, output to stdout");
        exit(0)
    }
    if matched.opt_present("version") {
        eprintln!("{}", env!("CARGO_PKG_VERSION"));
        exit(0)
    }
    let files = if matched.free.is_empty() {
        vec!["-".into()]
    } else {
        matched.free
    };
    for path in files {
        let res = (|| if path == "-" {
            proc_it(stdin())
        } else {
            proc_it(File::open(&path)?)
        })();
        if let Err(e) = res {
            eprintln!("error ({path}): {e}")
        }
    }
}
