use char_classes::any;
use getopts_macro::getopts::Matches;
use mtsyntax_plus::{build, parser, BuildContext, Error, OutputContext, Rule};
use std::{
    convert::Infallible,
    env::args,
    fmt::{Debug, Display},
    fs::File,
    io::{self, stdin, stdout, Read, Write},
    num::NonZeroU32,
    process::exit,
    str::FromStr,
};

#[derive(Debug)]
struct Config {
    spaces: NonZeroU32,
    newline: String,
    rules_only: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            spaces: NonZeroU32::new(4).unwrap(),
            newline: "\n".into(),
            rules_only: false,
        }
    }
}

fn error_exit(e: Error) -> Result<Infallible, io::Error> {
    match e {
        Error::UndefineRef(name) => {
            eprintln!("BuildError: undefine reference `{name}`");
        },
        Error::RepeatDefineName(name) => {
            eprintln!("BuildError: repeat define name `{name}`");
        },
        Error::RefNotARegexp(name) => {
            eprintln!("BuildError: reference `{name}` is not a regexp define");
        },
        Error::IOError(e) => Err(e)?,
    }
    exit(3)
}

fn unwrap_parsed<T>(
    result: Result<T, peg::error::ParseError<peg::str::LineCol>>,
) -> T {
    result.unwrap_or_else(|e| {
        eprintln!("ParseError: at {}:{},",
            e.location.line,
            e.location.column,
        );
        eprintln!("expected {}", e.expected);
        exit(3)
    })
}

fn output(
    rules: Vec<Rule<'_>>,
    cfg: &Config,
    indent: &str,
    mut out: impl Write,
) -> io::Result<()> {
    let mut ctx = BuildContext::default();
    let mut octx =
        OutputContext::new(|args| {
            write!(&mut out, "{args}")
        });

    octx.newline_str = &cfg.newline;
    if let Some(' ') | None = indent.chars().next() {
        octx.indent_level = indent.len() as u32 / cfg.spaces;
        octx.indent_str = " ".repeat(cfg.spaces.get() as usize).leak();
    } else {
        octx.indent_level = indent.len() as u32;
        octx.indent_str = "\t";
    }

    if let Err(e) = build(rules, &mut octx, &mut ctx) {
        eprintln!();
        error_exit(e)?;
    }
    Ok(())
}

fn proc_it(mut io: impl Read, cfg: &Config) -> io::Result<()> {
    let mut input = String::new();
    io.read_to_string(&mut input)?;
    drop(io);

    if cfg.rules_only {
        let rules = unwrap_parsed(parser::rule_list(&input));
        let indent = input.split_once(any!(^" \t"))
            .map_or(&*input, |it| it.0);
        print!("{indent}");
        output(rules, cfg, indent, stdout().lock())?;
        return Ok(());
    }

    let (begin, rules, end) = unwrap_parsed(parser::script(&input));

    let mut out = stdout().lock();

    let indent = begin
        .rsplit_once(any!(^" \t"))
        .map_or(begin, |(_, ind)| ind);

    write!(&mut out, "{begin}// Generated by mtsyntax-plus begin\n{indent}")?;

    output(rules, cfg, indent, &mut out)?;

    write!(&mut out, "// Generated by mtsyntax-plus end\n{end}")?;

    Ok(())
}

fn opt_parse<T>(matched: &Matches, nm: &str) -> Option<T>
where T: FromStr,
      T::Err: Display,
{
    Some(matched.opt_get(nm).transpose()?
                .unwrap_or_else(|e|
    {
        eprintln!("Parse option '{nm}' failed: {e}");
        exit(2)
    }))
}

fn main() {
    let options = getopts_macro::getopts_options! {
        -r  --rules         "Parse rules only";
        -s  --spaces=N      "Indent spaces";
        -n  --newline=S     "Newline string";
        -h  --help          "Show help message";
        -v  --version       "Show version";
        .parsing_style(getopts_macro::getopts::ParsingStyle::FloatingFrees)
    };
    let args = &mut args();
    let proc = args.next().unwrap();
    let matched = match options.parse(args) {
        Ok(matched) => matched,
        Err(e) => {
            eprintln!("{e}");
            exit(2)
        },
    };
    if matched.opt_present("help") {
        let biref = options.short_usage(&proc);
        let about = "将MT管理器语法进行强化, 使其正则定义可以携带颜色";
        let info = format!("{biref} [FILES..]\n{about}");
        let usage = options.usage(&info);
        println!("{usage}");
        println!("input from stdin, output to stdout");
        exit(0)
    }
    if matched.opt_present("version") {
        eprintln!("{}", env!("CARGO_PKG_VERSION"));
        exit(0)
    }

    let mut cfg = Config::default();
    macro_rules! parse_cfg {
        ($($field:ident),+ $(,)?) => {
            $(
                if let Some($field) = opt_parse(&matched, stringify!($field)) {
                    cfg.$field = $field;
                }
            )+
        };
    }
    parse_cfg! {
        spaces,
        newline,
    }
    cfg.rules_only = matched.opt_present("rules");

    let files = if matched.free.is_empty() {
        vec!["-".into()]
    } else {
        matched.free
    };

    for path in files {
        let res = (|| if path == "-" {
            proc_it(stdin(), &cfg)
        } else {
            proc_it(File::open(&path)?, &cfg)
        })();
        if let Err(e) = res {
            eprintln!("error ({path}): {e}")
        }
    }
}
